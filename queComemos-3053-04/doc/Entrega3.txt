1) Debido a que sería conveniente mantener centralizado el almacenamiento de los perfiles de usuario, se modeló a la clase RepositorioDeRecetas bajo el patrón Singleton, evitando así múltiples instancias de la misma. De esta manera se garantiza la unicidad del repositorio.
La colección de los perfiles se modeló con un diccionario, indexado por nombre de usuario, para garantizar la unicidad de los nombres (condición implícita en el enunciado, que dice que el método get retorna un único usuario, según su nombre) y optimizar las búsquedas, inserciones, remociones y actualizaciones de perfiles individuales. Por otro lado, la búsqueda general, en base a nombre y condiciones, se modeló con una única abstracción, en la cual se consulta siempre que el nombre esté contenido en el del usuario prototipo, y se delega al usuario la comprobación de las condiciones, retornando true siempre que el prototipo no tenga condiciones, y en caso contrario chequea si las cumple o no.

Para el manejo de las solicitudes, se implementó una clase Administrador, que por el momento también está modelada con el patrón Singleton (el enunciado habla de un único administrador).
Los usuarios (o perfiles de usuario más concretamente) se instanciarán mediante un factory method, crearPerfil/0, el cual se encargará de registrar al usuario recién creado con el administrador. Este cuenta con un conjunto de solicitudes pendientes de aprobación (modelado con una colección de tipo Set de usuarios, para evitar solicitudes duplicadas) en el que se almacenarán dichas solicitudes, para ser procesadas más tarde. Además, cuenta con dos formas de procesar solicitudes: rechazando/aprobando todas, o consultando el conjunto para rechazar/aprobar cada una, individualmente. Aceptar una solicitud consiste en agregar al perfil de usuario al Repositorio de Usuarios, y notificar al mismo mediante el método de callback que este expone, solicitudAceptada/0. El rechazo se comporta de la misma manera, con la diferencia que cuenta con un parámetro más, el motivo de rechazo, y que no agrega el perfil al Repositorio de Usuarios.

2) Se implementó la clase RepositorioRecetasExterno, nuevamente, de instancia única, para interfasear al componente externo, teniendo como única tarea recuperar todas las recetas externas, convirtiéndolas al formato de recetas interno. Para esto, se utilizó la API de Google Gson.

3) para resolver los requerimientos con observer, tomamos a la clase repositorioDeRecetas ya que es en la cual se efectúa
el evento listar, al final de listar se notifica a cada observador de lo sucedido, para ello tenemos la colección 
monitores y dos métodos setMonitor y getMonitor, para agregar o quitar a los monitores que deseen obtener una notificación
de cada consulta.

Los Monitores necesitan tener contadores para luego mostrar cual fue la receta con mayor cantidad de consultas, según cada 
criterio, por cantidad de horas, por veganos que la consultaron, etc, entonces cuando se las notifican a todas realizan 
su propia operación dentro de sus responsabilidades.

4) En lugar de utilizar un patrón observer, utilizamos una colección de monitores pasándola por parámetro al método listar
el cual notifica a todos los monitores de esta colección.
Consideramos que no es un observer, aunque se parece, porque el observer plantea que la colección sea un atributo, y que 
existan los métodos agregar y quitar observadores de la misma


De las dos soluciones planteadas en este tp, elegimos la que implementa el observer ya que nos permite por un lado, registrar 
cada uno de los monitores que tiene asociada una consulta de receta y realizar las acciones correspondientes de acuerdo a ella, 
y por el otro tenemos mayor cohesión, permite delegar en la notificación cuando se lista la receta (consulta).
Además esta solución permite fácilmente agregar nuevos monitores (en la otra es más tedioso porque se debería asignar una nueva 
lista con los monitores a agregar)



